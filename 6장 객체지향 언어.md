6장 정리노트 !

객제지향 언어

클래스와 객체

클래스의 정의 
- 클래스란 객체를 정의해 놓은 것

클래스 의 용도
-클래스는 객체를 생성하는데 사용

# 1. 객체와 인스턴스
객체 : 모든 인스턴스를 대표하는 일반적 용어
인스턴스 : 특정 클래스로부터 생성된 객체

클래스 ->(인스턴스화)->인스턴스(객체)

!!클래스가 왜 필요한가?
>>객체를 생성하기 위해

!!객체가 왜 필요한가?
>> 객체를 사용하기 위해

!!객체를 사용한다는 것은?
>> 객체가 가진 속성과기능을 사용하려고

# 1. 하나의 소스파일에 여러 클래스 작성

1. hello2. java //소스파일 이름
   public  class hello2 {} //접근제어자 클래스
       	    class Hello2 {}

//소스파일 이름과 public 클래스 이름과 일치해야함
- 대소문자 구분
- 하나의 소스파일에는 하나의 pubilc class만 허용
- pubilc class 가  없는 경우는 class중에 하나만 같아도 됨

 ## hello2. java //소스파일 이름
     class hello1 {}  //불일치
     class hello2 {}  //O
     class Hello2 {} //X 대문자
     class heoll3 {} //X 불일치


# 1. 객체의 생성과 사용

1. 객체의 생성
   클래스명 변수명;
  변수명 = new 클래스명

간략화하면
>> 클래스명 변수명 = new 클래스명();

2. 객체의 사용

참조변수.메소드();
t.channel = 7;
t.channelDown(); //메소드 사용
System.out println();

>> 클래스 작성 -> 객체생성 -> 객체사용


3. 객체 배열
- 객체 배열 == 참조변수 배열

Tv. tv1 tv2 tv3; -> Tv[] tvArr = new Tn[3]; //객체배열 생성

tvArr[0] = new Tv(); //객체배열에 객체생성
tnArr[1] = new Tv();
tvArr[2] = new Tv();  ->>>      Tv[] TvArr={new Tn(),new Tn(),new Tn()};

객체배열을 만들고 객체를 생성해주는 걸 잊지말자.


# 1. 클래스의 정의

클래스 == 데이터 + 함수 // 함수 ==메서드(명령문묶음,작업하는거)

1. 변수 - 하나의 데이터를 저장할 수 있는 공간
2. 배열 - 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
3. 구조체 - 서로 관련된 여러 데이터를 하나로 저장할 수 있는 공간
4. 클래스 - 데이터와 함수의 결합(구조체 + 함수) 

# 2. 클래스의 정의 2

클래스 
- 설계도
- 데이터 + 함수
- 사용자의 정의 타입

사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다.

class Time{
   int hour;
   int minute;
   int second;
}

Time t = new Time();           Time t = new Time(12,34,56);
t.hour = 12
t.minute = 34
t.second = 56  --->>>>

# 3. 선언위치에 따른 변수의 종류

클래스영역은 - 
1. iv(인스턴스변수),cv(클래스변수)
>클래스영역에는 변수나 선언문만 가능
ex) y = 3 + 4 , System.out.println() 같은거 못 들어감
-메서드는 순서는 따로 상관없다.
- 생성시기 인스턴스가 생성되었을때 == 객체가 생성되었을때
객체는 iv(변수)를 묶어놓은거다
- class영역에 있는 변수는 iv

2. cv(클래스변수)
- 생성시기 -> 클래스가 메모리에 올라갈 때
- 아무때나 사용가능하다
- 객체생성없이 사용가능하다
- 자동으로 생성되기 떄문에 객체생성이 필요없다

<CPU <-> <RAM> <- > <SSD(디스크)>
-CPU는 램(메모리)하고만 일한다.



3. 메서드영역은 - lv(지역변수)
- 지역변수는 클래스 영역 이외의 영역에 선언
- 객체가 생성

!!정리 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

- 영역은 클래스영역(iv,cv(static)),메서드영역(lv)   두가지 있다
- 객체는 iv변수를 묶은 거다 
- iv는 객체생성시 생긴다.


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

4. 클래스변수와 인스턴스 변수
1. cv는 클래스이름.변수명 = 객체;

Card. c = new Card();   //참조변수 c
c.kind = "heart"
c.number = 5;// 여기까지 iv
c.width = 200;
c.heigth = 300; //cv  ->> 사용은 가능하나 권장하지 않음

cv 앞에 클래스이름을 써는 방법
Card.width = 200;
Card.heigth = 300;

클래스변수는 앞에 클래스이름을 써는 식을 추천

# 4. 메서드란
1. 문장들을 묶어놓은 것 == 명령문을 묶어놓은 것

2. 메서드의 장점
- 코드의 중복을 줄일 수 있다.
- 코드의 관리가 쉽다
- 코드를 재사용할 수 있다.
- 코드가 간결해서 이해하기 쉬워진다.

3. 메서드의 작성
- 반복적으로 수행되는 여러 문장을 메서드로 작성
- 하나의 메서드는 한 가지 기능만 수행하도록 작성

메서드 = 선언부 + 구현부 로 이루어졌다.

반환타입 메서드 이름 (타입 변수명, 타입변수명 . . .)//선언부
{
       int result = a + b;
       return result;                      //구현부
}
- 매개변수(입력) 작업에 필요한 값을 입력


4. 메서드의 구현부
지역변수 : 메서드 내에 선언된 변수
[1]
int add(int x, int y){
   int result = x + y;
   return result;

}
[2]
int multiply(int x, int y){   //start
   int result = x * y;
   return result;

}                             //end

start영역부터 end영역까지가 메소드의 영역
그렇기 때문에[1],[2]가 변수이름이 같아도 겹치지 않아서 사용가능

5. 메소드의 호출

1. 메서드이름(값1,값2, ...) //메서드를 호출하는 방법 

print99danAll(); //void print99danAll()을 호출


int result = add(3, 5); //int add(int x, int y)를 호출하고 결과를 result에 저장
-void가 아닌 경우 대입연산자를 사용하고 작업결과 저장할 변수를 써준다
   int result = add(3, 5);   //result 저장할 변수

# 5. return문
실행 중인 메서드를 종료하고 호출하는 곳으로 되돌아간다

void printGugudan(int dan) {
   if(!2 <=2 dan && dan <= 9)){
      return; // dan의 값이 2~9가 아닌경우, 호출한 곳으로 그냥 되돌아간다

      for(int i=1; i<=9; i++){
         syso("%d * %d = %d%n, dan,i,dan*i);

      }
   }   return;; //반환타입 void이므로 생략가능. 컴파일러가 자동추가
}

- 반환타입이 void가 아닌 경우, 반드시 return문 필요


# 5. 호출 스택(call stack)
- 스택: 밑이 막힌 상자. 위에 차곡차곡 쌓인다.
- 메서드가 호출되면 호출 스택에 메모리 할당, 종료되면 해제
   
# 6. 기본형 매개변수
기본형 매개변수 - 변수의 값을 읽기만 할 수 있다
참조형 매개변수 - 변수의 값을 읽고 변경할 수 있다

# 7. static메서드 와 인스턴스 메서드
- static이 있으면 static 메서드, 없으면 인스턴스 메서드

인스턴스 메서드(객체생성 o)
- 인스턴스 생성 후, 참조변수.메서드이름()으로 호출
- 인스턴스 멤버(iv,im)와 관련된 작업을 하는 메서드
- 메서드 내에서 인스턴스 변수(iv) 사용가능

static메서드(클래스메서드)(객체생성x)
- 객체생성없이 클래스이름.메서드이름()으로 호출
- 인스턴스 멤버(iv,im)와 관련없는 작업을 하는 메서드
- 메서드 내에서 인스턴스 변수(iv) 사용불가

$$ iv 사용여부에 따라 구분한다.

static을 언제 붙여야 할까??
>> 속성(멤버변수)중에서 공통 속성에 static을 붙인다.

인스턴스 멤버(iv,im)을 사용하지 않는 메서드에 static을 붙인다.
>>인스턴스를 사용하지 않을 때 static

1. 메서드 간의 호출과 참조

static 메서드는 인스턴스 변수(iv)를 사용할 수 없다.
class TestClass {
   int iv //인스턴스 변수, iv는 객체생성 후 사용가능
   static int cv // 클래스 변수

   void intstanceMethod(){ //인스턴스 메서드, 객체생성후 호출가능
      Syso(iv); //인스턴스 변수 사용 가능
      syso(cv); // 클래스 변수 사용할 수 있다.언제나 사용가능
   }
 static void staticMethod(){ //static메서드
   syso(iv); // 에러!! 인스턴스 변수는 사용할 수 없다
   syso(cv); // 클래스변수는 사용할 수 있다.
 }

}

2. 메서드 간의 호출과 참조
1. static 메서드는 인스턴스 메서드(im)를 호출할 수 없다.
class TestClass {
   void intstanceMethod() {} //인스턴스 메서드
      static void staticMethod(){} //static메서드
   
   void instanceMethod2(){  //인스턴스 메서드
      intstanceMethod();    // 다른 인스턴스메서드를 호출할 수 있다
      staticMethod();   //static메서드를 호출한다.언제나 가능
   }
   static void staticMethod2(){ //static 메서드
      intstanceMethod();        //에러!!인스턴스메서드 호출xxxx
      staticMethod();           // static메서드 호출할 수 있다.
   }
   }
}
!!!!!!!!!!!!!!!!!!!
static 메서드는 static 메서드 호출가능
static 메서드는 인스턴스 변수 사용xx


static 변하지 않는   instance 변하는
변하지 않는 것은 변하는 거 내에 속할 수 있지만
변하는 것에 변하지 않는 거는 속할 수 없다.

# 8. 오버로딩
- 한 클래스 안에 같은 이름의 메서드 여러 개 정의하는 것
자바에서는 오버로딩을 지원하기 때문에 그냥 쓸 수 있다 
예)) println (정수,실수,문자,문자열) println이라는 같은 이름으로
   다른 형태의 타입을 쓸수 있다

- 오버로딩이 성립하기 위한 조건
1. 메서드 이름이 일치
- int add
- long add
- int add(int[]a)
2. 매개변수의 개수 or 타입이 달라야 한다
- int a, int b
- long a, long b
- Arrays 배열
3. 반환 타입은 영향없다.
변수 앞에 int든 short든 뭐가 오든 영향이 없다

@@ ambiguous = 모호하다

 













































